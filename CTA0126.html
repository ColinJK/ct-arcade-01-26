<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Breakline - P2P Arcade Racer</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        body {
            margin: 0;
            background-color: #050505;
            background-image: url('https://colinjk.github.io/ct-arcade-01-26/menu-background.png');
            background-size: cover;
            background-position: center;
            color: #ffffff;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #1a1a1a;
            max-width: 100%;
            max-height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 10, 10, 0.98);
            padding: 2.5rem;
            border-radius: 16px;
            border: 1px solid #00bcd4;
            z-index: 10;
            min-width: 340px;
            box-shadow: 0 0 40px rgba(0, 188, 212, 0.15);
        }

        #ui-title-container {
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
        }

        #ui-title-img {
            max-width: 300px;
            height: auto;
            filter: drop-shadow(0 0 8px rgba(0, 188, 212, 0.6));
        }

        #loading-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00bcd4;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 5;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        #hud > * { pointer-events: auto; }

        .stat-box {
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 20px;
            border-radius: 8px;
            border-left: 4px solid #00bcd4;
            font-weight: 800;
            color: #fff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }

        input[type="text"] {
            padding: 14px;
            border-radius: 8px;
            border: 1px solid #333;
            background: #111;
            color: white;
            font-size: 16px;
            margin-bottom: 12px;
            width: 260px;
            display: block;
            margin: 10px auto;
            text-align: center;
            transition: border-color 0.3s;
        }

        button {
            padding: 14px 28px;
            border-radius: 8px;
            border: none;
            background: #00bcd4;
            color: #000;
            font-weight: 900;
            cursor: pointer;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            margin: 5px;
        }

        button:hover { background: #00e5ff; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 188, 212, 0.4); }
        .btn-solo { background: #4CAF50; color: white; }
        .btn-danger { background: #f44336; color: white; }
        
        .hidden { display: none !important; }

        label { display: block; font-size: 11px; color: #666; margin-top: 12px; text-transform: uppercase; font-weight: bold; }

        #settings-panel {
            background: rgba(25, 25, 25, 0.5);
            border: 1px solid #222;
            padding: 1rem;
            border-radius: 12px;
            margin-top: 15px;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #00bcd4;
            cursor: pointer;
        }

        .car-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }
        .car-option {
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            background: #111;
            width: 60px;
        }
        .car-option img { width: 100%; display: block; }
        .car-option.selected { border-color: #00bcd4; background: #00bcd433; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="loading-msg">Booting Systems...</div>
        
        <!-- HUD -->
        <div id="hud" class="hidden">
            <div>
                <div id="lap-counter" class="stat-box">LAP: 1/3</div>
            </div>
            <button id="btn-quit" class="btn-danger">QUIT</button>
        </div>
    </div>

    <div id="ui-layer" class="hidden">
        <div id="ui-title-container">
            <img id="ui-title-img" src="https://colinjk.github.io/ct-arcade-01-26/game-title.png" alt="Neon Breakline">
        </div>
        <div id="ui-content"></div>
    </div>

    <script>
        // --- HELPERS ---
        window.copyToClipboard = (text) => {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
        };

        function createChainWalls(scene, points, thickness, flip, label = 'wall') {
            const bodies = [];
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len === 0) continue;
                let nx = -dy / len;
                let ny = dx / len;
                if (flip) { nx = -nx; ny = -ny; }
                const center = { x: (p1.x + p2.x + nx * thickness)/2, y: (p1.y + p2.y + ny * thickness)/2 };
                const vertices = [
                    { x: p1.x - center.x, y: p1.y - center.y },
                    { x: p2.x - center.x, y: p2.y - center.y },
                    { x: p2.x + nx * thickness - center.x, y: p2.y + ny * thickness - center.y },
                    { x: p1.x + nx * thickness - center.x, y: p1.y + ny * thickness - center.y }
                ];
                bodies.push(scene.matter.add.fromVertices(center.x, center.y, vertices, { 
                    isStatic: true, restitution: 0.1, friction: 0, frictionStatic: 0, label: label
                }));
            }
            return bodies;
        }

        // --- GLOBAL STATE ---
        const LAPS_TO_WIN = 3;
        let savedVol = localStorage.getItem('neon-volume');
        let initialVolume = 0.1;
        if (savedVol !== null) {
            let parsed = parseFloat(savedVol);
            if (!isNaN(parsed) && isFinite(parsed)) initialVolume = parsed;
        }

        // GLOBAL SPEED FACTOR - Locked
        const GLOBAL_SPEED_FACTOR = 0.05;

        const Net = {
            peer: null,
            myId: null,
            creatorId: null,
            playerName: localStorage.getItem('p2p-racer-name') || "Racer_" + Math.floor(Math.random()*999),
            carType: localStorage.getItem('p2p-racer-car') || 'car1',
            volume: initialVolume,
            connections: {},
            players: {},
            isHost: false,
            isSolo: false,
            ready: false,
            gameOver: false
        };

        const TRACK_POINTS_INNER = [
            {x:313, y:277},{x:745, y:280},{x:766, y:323},{x:731, y:370},{x:497, y:515},
            {x:486, y:604},{x:545, y:672},{x:734, y:677},{x:786, y:690},{x:766, y:720},
            {x:314, y:729},{x:266, y:705},{x:302, y:641},{x:452, y:537},{x:507, y:496},
            {x:568, y:419},{x:561, y:372},{x:507, y:333},{x:418, y:320},{x:338, y:322},
            {x:290, y:314},{x:302, y:297}
        ];

        const TRACK_POINTS_OUTER = [
            {x:296, y:193},{x:748, y:189},{x:822, y:213},{x:857, y:269},{x:867, y:369},
            {x:828, y:432},{x:647, y:548},{x:824, y:569},{x:883, y:612},{x:912, y:724},
            {x:899, y:790},{x:828, y:829},{x:269, y:844},{x:189, y:828},{x:154, y:775},
            {x:148, y:690},{x:167, y:588},{x:380, y:437},{x:188, y:392},{x:171, y:314},
            {x:181, y:243},{x:216, y:200},{x:269, y:191}
        ];

        window.onload = () => {
            if (typeof Phaser === 'undefined') {
                document.getElementById('loading-msg').innerText = "Phaser Load Error";
                return;
            }
            startGame();
        };

        function startGame() {
            class NetworkManager {
                constructor(sceneEventBus) { this.events = sceneEventBus; }
                init() {
                    if (Net.peer) return;
                    Net.peer = new Peer(null, { debug: 1 });
                    Net.peer.on('open', (id) => {
                        if (!Net.isSolo) {
                            if (!Net.myId || Net.myId.startsWith('local_')) Net.myId = id;
                        }
                        if (!Net.players[id]) Net.players[id] = { id, laps: 0 };
                        Object.assign(Net.players[id], { name: Net.playerName, carType: Net.carType });
                        this.events.emit('net-ready', id);
                    });
                    Net.peer.on('connection', (conn) => this.handleConnection(conn));
                }
                connectToPeer(hostId) {
                    if(!Net.peer || hostId === Net.myId) return;
                    Net.creatorId = hostId;
                    const conn = Net.peer.connect(hostId);
                    this.handleConnection(conn);
                }
                handleConnection(conn) {
                    conn.on('open', () => {
                        Net.connections[conn.peer] = conn;
                        conn.send({ type: 'HELLO', player: Net.players[Net.myId], creatorId: Net.creatorId });
                        if (Object.keys(Net.players).length > 1) {
                            conn.send({ type: 'PEER_LIST', list: Object.keys(Net.players), creatorId: Net.creatorId });
                        }
                        this.updateHostStatus();
                        this.events.emit('player-updated');
                    });
                    conn.on('data', (data) => this.handleData(conn.peer, data));
                    conn.on('close', () => this.removePlayer(conn.peer));
                    conn.on('error', () => this.removePlayer(conn.peer));
                }
                handleData(senderId, data) {
                    switch(data.type) {
                        case 'HELLO':
                            if (data.creatorId && !Net.creatorId) Net.creatorId = data.creatorId;
                            if (!Net.players[senderId]) Net.players[senderId] = { id: senderId, laps: 0 };
                            Object.assign(Net.players[senderId], data.player);
                            this.updateHostStatus();
                            this.events.emit('player-updated');
                            break;
                        case 'PEER_LIST':
                            if (data.creatorId && !Net.creatorId) Net.creatorId = data.creatorId;
                            data.list.forEach(id => (id !== Net.myId && !Net.connections[id]) && this.connectToPeer(id));
                            break;
                        case 'START_GAME': this.events.emit('start-game'); break;
                        case 'GAME_UPDATE': if (Net.players[senderId]) Object.assign(Net.players[senderId], data); break;
                        case 'RACE_FINISHED': this.events.emit('race-finished', data.winnerId); break;
                        case 'RESET_TO_LOBBY': this.events.emit('reset-to-lobby'); break;
                    }
                }
                broadcast(data) {
                    if (Net.isSolo) return;
                    Object.values(Net.connections).forEach(c => c.open && c.send(data));
                }
                removePlayer(id) {
                    delete Net.players[id];
                    delete Net.connections[id];
                    this.updateHostStatus();
                    this.events.emit('player-left', id);
                    this.events.emit('player-updated');
                }
                updateHostStatus() {
                    const allIds = Object.keys(Net.players).sort();
                    if (Net.creatorId && Net.players[Net.creatorId]) {
                        Net.isHost = (Net.myId === Net.creatorId);
                    } else {
                        const newHostId = allIds[0];
                        if (Net.creatorId !== newHostId) { Net.creatorId = newHostId; }
                        Net.isHost = (Net.myId === Net.creatorId);
                    }
                }
            }

            const eventBus = new Phaser.Events.EventEmitter();
            const network = new NetworkManager(eventBus);

            class MenuScene extends Phaser.Scene {
                constructor() { super('Menu'); }
                preload() {
                    this.load.image('car1', 'https://colinjk.github.io/ct-arcade-01-26/car1-sprite.png');
                    this.load.image('car2', 'https://colinjk.github.io/ct-arcade-01-26/car2-sprite.png');
                    this.load.image('car3', 'https://colinjk.github.io/ct-arcade-01-26/car3-sprite.png');
                    this.load.image('track_img', 'https://colinjk.github.io/ct-arcade-01-26/track.png');
                    this.load.audio('bgm', 'https://colinjk.github.io/ct-arcade-01-26/bg-music.wav');
                    this.load.audio('accel', 'https://colinjk.github.io/ct-arcade-01-26/accel.wav');
                }
                create() {
                    document.getElementById('loading-msg').style.display = 'none';
                    document.body.style.backgroundImage = "url('https://colinjk.github.io/ct-arcade-01-26/menu-background.png')";
                    
                    if (!Net.isSolo) network.init();
                    
                    Net.ready = true;
                    Net.isSolo = false;
                    Net.gameOver = false;
                    this.sound.volume = Net.volume;
                    document.getElementById('ui-layer').classList.remove('hidden');
                    this.renderMenu(document.getElementById('ui-content'));
                }
                renderMenu(container) {
                    container.innerHTML = `
                        <label>YOUR NAME</label>
                        <input type="text" id="inp-name" value="${Net.playerName}" maxlength="12">
                        <label>CHOOSE YOUR CAR</label>
                        <div class="car-selector">
                            <div class="car-option ${Net.carType === 'car1' ? 'selected' : ''}" data-car="car1"><img src="https://colinjk.github.io/ct-arcade-01-26/car1-sprite.png"></div>
                            <div class="car-option ${Net.carType === 'car2' ? 'selected' : ''}" data-car="car2"><img src="https://colinjk.github.io/ct-arcade-01-26/car2-sprite.png"></div>
                            <div class="car-option ${Net.carType === 'car3' ? 'selected' : ''}" data-car="car3"><img src="https://colinjk.github.io/ct-arcade-01-26/car3-sprite.png"></div>
                        </div>
                        <div style="display:flex; justify-content:center; flex-wrap:wrap;">
                            <button id="btn-solo" class="btn-solo">Practice (Solo)</button>
                            <button id="btn-create">Create Lobby</button>
                        </div>
                        <input type="text" id="inp-room" placeholder="Paste ID here">
                        <button id="btn-join" style="width:100%;">Join Lobby</button>
                        <div id="settings-panel">
                            <label>VOLUME (${Math.round(Net.volume * 100)}%)</label>
                            <input type="range" id="vol-slider" min="0" max="1" step="0.05" value="${Net.volume}">
                        </div>
                    `;
                    const volSlider = document.getElementById('vol-slider');
                    volSlider.oninput = (e) => {
                        Net.volume = parseFloat(e.target.value);
                        this.sound.volume = Net.volume;
                        localStorage.setItem('neon-volume', Net.volume);
                        volSlider.previousElementSibling.innerText = `VOLUME (${Math.round(Net.volume * 100)}%)`;
                    };
                    container.querySelectorAll('.car-option').forEach(opt => {
                        opt.onclick = () => {
                            container.querySelectorAll('.car-option').forEach(o => o.classList.remove('selected'));
                            opt.classList.add('selected');
                            Net.carType = opt.dataset.car;
                        };
                    });
                    document.getElementById('btn-solo').onclick = () => {
                        Net.isSolo = true;
                        if (Net.peer) { Net.peer.destroy(); Net.peer = null; }
                        Net.myId = 'player_solo_' + Math.floor(Math.random()*9999);
                        Net.players = {}; 
                        this.saveSettings();
                        document.getElementById('ui-layer').classList.add('hidden');
                        this.scene.start('Game');
                        this.scene.launch('HUD'); // Launch HUD
                    };
                    document.getElementById('btn-create').onclick = () => { this.saveSettings(); Net.creatorId = Net.myId; this.scene.start('Lobby'); };
                    document.getElementById('btn-join').onclick = () => {
                        const room = document.getElementById('inp-room').value.trim();
                        if (room) { this.saveSettings(); network.connectToPeer(room); this.scene.start('Lobby'); }
                    };
                }
                saveSettings() {
                    const name = document.getElementById('inp-name').value.trim() || "Racer";
                    Net.playerName = name;
                    localStorage.setItem('p2p-racer-name', name);
                    localStorage.setItem('p2p-racer-car', Net.carType);
                    if (!Net.players[Net.myId]) Net.players[Net.myId] = { id: Net.myId, laps: 0 };
                    Net.players[Net.myId].name = name;
                    Net.players[Net.myId].carType = Net.carType;
                }
            }

            class LobbyScene extends Phaser.Scene {
                constructor() { super('Lobby'); }
                create() {
                    const ui = document.getElementById('ui-layer');
                    ui.classList.remove('hidden');
                    const content = document.getElementById('ui-content');
                    this.render(content);
                    eventBus.on('player-updated', () => this.render(content));
                    eventBus.on('start-game', () => this.startGame());
                }
                render(container) {
                    const hostId = Net.creatorId;
                    let html = `<h2 style="color:#00bcd4; margin-top:0;">LOBBY</h2>
                    <div style="margin-bottom:15px; background:#111; padding:12px; border-radius:8px; border:1px solid #222;">
                        <span style="color:#666; font-size:10px;">ROOM ID:</span> <b style="color:#00bcd4;">${hostId || '...'}</b>
                        <button onclick="window.copyToClipboard('${hostId}')" style="padding:4px 8px; font-size:10px; background:#333; margin-left:10px;">COPY</button>
                    </div><div style="text-align:left; background:#000; padding:10px; border-radius:8px; border:1px solid #1a1a1a;">`;
                    Object.values(Net.players).forEach(p => {
                        html += `<div style="padding:8px; border-bottom:1px solid #111; display:flex; justify-content:space-between; align-items:center;">
                            <span>‚óè ${p.name || 'Unknown'}</span>
                            <img src="https://colinjk.github.io/ct-arcade-01-26/${p.carType}-sprite.png" style="height:20px;">
                        </div>`;
                    });
                    html += `</div>`;
                    if (Net.isHost) html += `<button id="btn-start" style="margin-top:20px; width:100%; background:#4CAF50;">START RACE</button>`;
                    container.innerHTML = html;
                    const b = document.getElementById('btn-start');
                    if (b) b.onclick = () => { network.broadcast({ type: 'START_GAME' }); this.startGame(); };
                }
                startGame() {
                    document.getElementById('ui-layer').classList.add('hidden');
                    this.scene.start('Game');
                    this.scene.launch('HUD');
                }
            }

            // --- HUD SCENE (MINIMAP) ---
            class HUDScene extends Phaser.Scene {
                constructor() { super('HUD'); }
                create() {
                    // Minimap Config
                    this.mapSize = 180;
                    this.mapScale = 0.2;
                    this.mapX = this.cameras.main.width - this.mapSize - 20;
                    this.mapY = this.cameras.main.height - this.mapSize - 20;

                    // Speedometer Text
                    this.speedText = this.add.text(this.mapX, this.mapY - 25, '0 KM/H', { 
                        font: '16px "Segoe UI", Arial', 
                        fill: '#00bcd4', 
                        fontWeight: '900',
                        stroke: '#000000',
                        strokeThickness: 3
                    });

                    // Background
                    const bg = this.add.graphics();
                    bg.fillStyle(0x000000, 0.8);
                    bg.fillRect(this.mapX, this.mapY, this.mapSize, this.mapSize);
                    bg.lineStyle(2, 0x00bcd4, 1);
                    bg.strokeRect(this.mapX, this.mapY, this.mapSize, this.mapSize);

                    // Track Geometry
                    const drawPath = (points, color) => {
                        bg.lineStyle(2, color, 0.8);
                        bg.beginPath();
                        points.forEach((p, i) => {
                            const mx = this.mapX + (p.x * this.mapScale);
                            const my = this.mapY + (p.y * this.mapScale);
                            if (i === 0) bg.moveTo(mx, my);
                            else bg.lineTo(mx, my);
                        });
                        bg.closePath();
                        bg.strokePath();
                    };
                    drawPath(TRACK_POINTS_INNER, 0x00bcd4);
                    drawPath(TRACK_POINTS_OUTER, 0x00bcd4);

                    this.dots = this.add.graphics();
                }

                update() {
                    this.dots.clear();
                    
                    // Update Speedometer
                    const myPlayer = Net.players[Net.myId];
                    if (myPlayer && typeof myPlayer.speed === 'number') {
                       // Scale speed to look like KM/H (arbitrary x20 multiplier)
                       this.speedText.setText(Math.floor(myPlayer.speed * 20) + ' KM/H');
                    }

                    // Update Dots
                    Object.values(Net.players).forEach(p => {
                        if (typeof p.x !== 'undefined' && typeof p.y !== 'undefined') {
                            const mx = this.mapX + (p.x * this.mapScale);
                            const my = this.mapY + (p.y * this.mapScale);
                            
                            // Clamp to map bounds just in case
                            if(mx >= this.mapX && mx <= this.mapX + this.mapSize && 
                               my >= this.mapY && my <= this.mapY + this.mapSize) {
                                
                                const isMe = (p.id === Net.myId);
                                this.dots.fillStyle(isMe ? 0x00ff00 : 0xff0000, 1);
                                this.dots.fillCircle(mx, my, isMe ? 4 : 3);
                            }
                        }
                    });
                }
            }

            class GameScene extends Phaser.Scene {
                constructor() { super('Game'); }
                create() {
                    Net.gameOver = false;
                    this.myLaps = 0;
                    this.hasReachedCheckpoint = false; 

                    if (!this.sound.get('bgm')) this.sound.play('bgm', { loop: true, volume: 0.4 });
                    this.accelSfx = this.sound.add('accel', { loop: true, volume: 0.6 });

                    document.getElementById('hud').classList.remove('hidden');
                    document.getElementById('lap-counter').innerText = `LAP: 1/${LAPS_TO_WIN}`;
                    document.getElementById('btn-quit').onclick = () => window.location.reload();

                    this.track = this.add.image(0, 0, 'track_img').setOrigin(0);
                    // Camera Zoom increased, but HUD Scene will stay fixed
                    this.cameras.main.setZoom(1.7);
                    this.cameras.main.setBounds(0, 0, this.track.width, this.track.height);

                    createChainWalls(this, TRACK_POINTS_INNER, 10, false, 'inner_island');
                    createChainWalls(this, TRACK_POINTS_OUTER, 20, true, 'outer_wall');

                    // Sensors
                    this.checkpointSensor = this.matter.add.rectangle(520, 230, 20, 100, { isSensor: true, isStatic: true, label: 'checkpoint' });
                    this.finishSensor = this.matter.add.rectangle(350, 790, 20, 100, { isSensor: true, isStatic: true, label: 'finish' });

                    this.playerData = {}; 
                    
                    if (Net.isSolo && !Net.myId) Net.myId = 'player_solo_' + Math.floor(Math.random()*9999);
                    
                    if (Net.isSolo && (!Net.players[Net.myId])) {
                        Net.players[Net.myId] = { id: Net.myId, name: Net.playerName, carType: Net.carType, laps: 0 };
                    }

                    Object.values(Net.players).forEach((p, idx) => {
                        p.x = 450 + (idx * 50); p.y = 790; p.angle = 0; p.laps = 0;
                        this.spawn(p);
                    });

                    const localEntry = this.playerData[Net.myId];
                    if (localEntry && localEntry.visual) {
                        this.cameras.main.startFollow(localEntry.visual, true, 0.1, 0.1);
                    }

                    this.keys = this.input.keyboard.addKeys({ up: 'UP', down: 'DOWN', left: 'LEFT', right: 'RIGHT', w: 'W', a: 'A', s: 'S', d: 'D' });

                    this.matter.world.on('collisionstart', (e) => {
                        e.pairs.forEach(pair => {
                            const labels = [pair.bodyA.label, pair.bodyB.label];
                            if (labels.includes(Net.myId)) {
                                if (labels.includes('checkpoint')) {
                                    this.hasReachedCheckpoint = true;
                                } else if (labels.includes('finish') && this.hasReachedCheckpoint) {
                                    this.myLaps++;
                                    this.hasReachedCheckpoint = false;
                                    document.getElementById('lap-counter').innerText = `LAP: ${Math.min(this.myLaps + 1, LAPS_TO_WIN)}/${LAPS_TO_WIN}`;
                                    if (this.myLaps >= LAPS_TO_WIN) this.showResult(Net.myId);
                                }
                            }
                        });
                    });

                    eventBus.on('race-finished', (winnerId) => this.showResult(winnerId));
                }

                spawn(p) {
                    const body = this.matter.add.rectangle(p.x, p.y, 20, 10, {
                        frictionAir: 0.015, 
                        mass: 1.2,        
                        restitution: 0.1, 
                        angularFriction: 0.8, // VERY HIGH rotation dampening on release
                        label: p.id,
                        chamfer: { radius: 3 }
                    });
                    this.matter.body.setAngle(body, 0); 
                    
                    const trail = this.add.particles(0, 0, 'car1', {
                        scale: { start: 0.2, end: 0 }, alpha: { start: 0.4, end: 0 }, tint: 0x00bcd4, lifespan: 300, blendMode: 'ADD', frequency: 30
                    });
                    
                    const visual = this.add.image(p.x, p.y, p.carType).setScale(0.38).setDepth(10);
                    
                    const hitboxDebug = this.add.graphics().setDepth(11).setAlpha(0.4);
                    
                    const text = this.add.text(0, 0, p.name || p.id.substr(0,4), { fontSize: '10px', fontStyle: 'bold', fill: '#fff', backgroundColor: '#000000cc' }).setOrigin(0.5).setDepth(100);
                    
                    this.playerData[p.id] = { body, visual, text, trail, hitboxDebug };
                }

                update() {
                    if (Net.gameOver) return;
                    
                    const my = this.playerData[Net.myId];
                    if (my) {
                        const b = my.body;

                        if (!Number.isFinite(b.position.x) || Math.abs(b.position.x) > 5000) {
                            console.warn("Physics instability detected! Resetting car.");
                            this.matter.body.setPosition(b, { x: 450, y: 790 });
                            this.matter.body.setVelocity(b, { x: 0, y: 0 });
                            this.matter.body.setAngle(b, 0);
                        }
                        
                        // Sync speed for HUD
                        Net.players[Net.myId].speed = b.speed;

                        // --- SKILLFUL RACER PHYSICS CONSTANTS ---
                        const BASE_THRUST = 0.085; 
                        const BASE_MAX_SPEED = 40; 
                        const BASE_TORQUE = 0.005; 

                        const effectiveThrust = BASE_THRUST * GLOBAL_SPEED_FACTOR;
                        const effectiveMaxSpeed = BASE_MAX_SPEED * GLOBAL_SPEED_FACTOR;
                        const effectiveTorque = BASE_TORQUE * GLOBAL_SPEED_FACTOR;

                        if (b.speed > effectiveMaxSpeed) {
                            this.matter.body.setSpeed(b, effectiveMaxSpeed);
                        }
                        
                        if (b.speed < 0.2) {
                             this.matter.body.setVelocity(b, {x:0, y:0});
                        }

                        // VELOCITY PROJECTION (SMOOTHED)
                        const vel = new Phaser.Math.Vector2(b.velocity.x, b.velocity.y);
                        if (vel.length() > 0.1) {
                            const angle = b.angle;
                            const forward = new Phaser.Math.Vector2(Math.cos(angle), Math.sin(angle));
                            const right = new Phaser.Math.Vector2(-Math.sin(angle), Math.cos(angle));

                            const forwardSpeed = vel.dot(forward);
                            const lateralSpeed = vel.dot(right);

                            // SLIDE FACTOR: 0.35 retains some drift momentum so it doesn't snap
                            const newLateralSpeed = lateralSpeed * 0.35; 

                            const newVel = forward.scale(forwardSpeed).add(right.scale(newLateralSpeed));
                            this.matter.body.setVelocity(b, newVel);
                        }

                        let throttling = false;
                        if (this.keys.up.isDown || this.keys.w.isDown) {
                            throttling = true;
                            this.matter.applyForce(b, { x: Math.cos(b.angle) * effectiveThrust, y: Math.sin(b.angle) * effectiveThrust });
                        } else if (this.keys.down.isDown || this.keys.s.isDown) {
                            throttling = true;
                            this.matter.applyForce(b, { x: -Math.cos(b.angle) * (effectiveThrust * 0.6), y: -Math.sin(b.angle) * (effectiveThrust * 0.6) });
                        }
                        
                        // Steering with Active Stabilization on release
                        let steerFactor = Math.min(b.speed / (effectiveMaxSpeed * 0.25), 1);
                        steerFactor = 0.15 + (0.85 * steerFactor);
                        const turnForce = effectiveTorque * steerFactor;

                        let isTurning = false;
                        if (this.keys.left.isDown || this.keys.a.isDown) {
                            b.torque = -turnForce;
                            isTurning = true;
                        } else if (this.keys.right.isDown || this.keys.d.isDown) {
                            b.torque = turnForce;
                            isTurning = true;
                        }

                        // ACTIVE STABILIZATION: If not turning, kill rotation fast
                        if (!isTurning) {
                            b.torque = b.angularVelocity * -0.1; // Counter-torque
                        }

                        if (throttling && !this.accelSfx.isPlaying) this.accelSfx.play();
                        else if (!throttling && this.accelSfx.isPlaying) this.accelSfx.stop();

                        Net.players[Net.myId].x = b.position.x;
                        Net.players[Net.myId].y = b.position.y;
                        Net.players[Net.myId].angle = b.angle;
                        Net.players[Net.myId].laps = this.myLaps;

                        network.broadcast({ type: 'GAME_UPDATE', x: b.position.x, y: b.position.y, angle: b.angle, laps: this.myLaps });
                        my.trail.emitParticleAt(b.position.x, b.position.y, throttling ? 2 : 0);
                    }

                    Object.keys(Net.players).forEach(id => {
                        const obj = this.playerData[id];
                        if (obj) {
                            const d = Net.players[id];
                            if (id !== Net.myId) {
                                obj.visual.x = Phaser.Math.Linear(obj.visual.x, d.x || 0, 0.2);
                                obj.visual.y = Phaser.Math.Linear(obj.visual.y, d.y || 0, 0.2);
                                obj.visual.setAngle(Phaser.Math.RadToDeg(d.angle || 0) + 90);
                            } else {
                                obj.visual.x = obj.body.position.x;
                                obj.visual.y = obj.body.position.y;
                                obj.visual.setAngle(Phaser.Math.RadToDeg(obj.body.angle) + 90);
                            }
                            
                            obj.text.setPosition(Math.round(obj.visual.x), Math.round(obj.visual.y - 30));
                            
                            obj.hitboxDebug.clear();
                            obj.hitboxDebug.fillStyle(0x00ff00, 0.3);
                            obj.hitboxDebug.beginPath();
                            const verts = obj.body.vertices;
                            obj.hitboxDebug.moveTo(verts[0].x, verts[0].y);
                            for (let i = 1; i < verts.length; i++) {
                                obj.hitboxDebug.lineTo(verts[i].x, verts[i].y);
                            }
                            obj.hitboxDebug.closePath();
                            obj.hitboxDebug.fillPath();
                        }
                    });
                }

                showResult(winnerId) {
                    if (Net.gameOver) return;
                    Net.gameOver = true;
                    this.accelSfx.stop();
                    const ui = document.getElementById('ui-layer');
                    ui.classList.remove('hidden');
                    
                    const isWinner = winnerId === Net.myId;
                    document.getElementById('ui-content').innerHTML = `
                        <h2 style="color:${isWinner ? '#FFD700' : '#00bcd4'};">${isWinner ? 'üèÅ VICTORY!' : 'üèÅ RACE END'}</h2>
                        <p>${Net.players[winnerId]?.name || 'Racer'} wins!</p>
                        <button onclick="window.location.reload()">Menu</button>
                    `;
                    document.getElementById('hud').classList.add('hidden');
                    // Stop HUD scene to clear map
                    this.scene.stop('HUD');
                }
            }

            new Phaser.Game({
                type: Phaser.AUTO, width: 950, height: 850, backgroundColor: '#050505', parent: 'game-container',
                scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
                physics: { 
                    default: 'matter', 
                    matter: { 
                        gravity: { x: 0, y: 0 }, 
                        debug: false,
                        positionIterations: 10,
                        velocityIterations: 10
                    } 
                },
                scene: [MenuScene, LobbyScene, GameScene, HUDScene]
            });
        }
    </script>
</body>
</html>
