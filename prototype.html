<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Breakline - P2P Arcade Racer</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        body {
            margin: 0;
            background-color: #0a0a0a;
            background-image: url('https://colinjk.github.io/ct-arcade-01-26/menu-background.png');
            background-size: cover;
            background-position: center;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
            width: 950px; 
            height: 850px; 
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #333;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 2rem;
            border-radius: 12px;
            border: 1px solid #00bcd4;
            z-index: 10;
            min-width: 320px;
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.2);
        }

        #ui-title-container {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        #ui-title-img {
            max-width: 280px;
            height: auto;
            filter: drop-shadow(0 0 5px rgba(0, 188, 212, 0.5));
        }

        #ui-title-text {
            font-size: 24px;
            margin: 0;
            color: #00bcd4;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #loading-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00bcd4;
            pointer-events: none;
        }

        #error-log {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            display: none;
            z-index: 1000;
            white-space: pre-wrap;
        }

        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            z-index: 5;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        #hud > * { pointer-events: auto; }

        .stat-box {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 6px;
            border-left: 4px solid #00bcd4;
            font-weight: bold;
            color: #fff;
        }

        input[type="text"] {
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #111;
            color: white;
            font-size: 16px;
            margin-bottom: 10px;
            width: 240px;
            display: block;
            margin: 10px auto;
            text-align: center;
        }

        button {
            padding: 12px 24px;
            border-radius: 4px;
            border: none;
            background: #00bcd4;
            color: black;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        button:hover { background: #00e5ff; transform: scale(1.05); }
        .btn-secondary { background: #444; color: white; margin-top: 10px; }
        .btn-danger { background: #f44336; color: white; }
        .btn-danger:hover { background: #ff5252; }
        
        .hidden { display: none !important; }

        label { display: block; font-size: 12px; color: #888; margin-top: 10px; }

        .car-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }
        .car-option {
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            background: #111;
            width: 60px;
        }
        .car-option img {
            width: 100%;
            height: auto;
            display: block;
        }
        .car-option.selected {
            border-color: #00bcd4;
            background: #00bcd433;
            transform: scale(1.1);
        }

        /* Settings CSS */
        #settings-panel {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #00bcd4;
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 10px;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #00bcd4;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="error-log"></div>
    
    <div id="game-container">
        <div id="loading-msg">Initializing Components...</div>
        
        <div id="hud" class="hidden">
            <div id="lap-counter" class="stat-box">LAP: 1/3</div>
            <button id="btn-quit" class="btn-danger">QUIT</button>
        </div>
    </div>

    <div id="ui-layer" class="hidden">
        <div id="ui-title-container">
            <img id="ui-title-img" src="https://colinjk.github.io/ct-arcade-01-26/game-title.png" alt="Neon Breakline">
            <h2 id="ui-title-text" class="hidden">NEON BREAKLINE</h2>
        </div>
        <div id="ui-content"></div>
    </div>

    <script>
        // --- HELPER FUNCTIONS ---
        window.copyToClipboard = (text) => {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
        };

        function createOuterWall(scene, points, thickness, flip) {
            const bodies = [];
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len === 0) continue;
                let nx = -dy / len;
                let ny = dx / len;
                if (flip) { nx = -nx; ny = -ny; }
                const ex = nx * thickness;
                const ey = ny * thickness;
                const center = { x: (p1.x + p2.x + ex)/2, y: (p1.y + p2.y + ey)/2 };
                const vertices = [
                    { x: p1.x - center.x, y: p1.y - center.y },
                    { x: p2.x - center.x, y: p2.y - center.y },
                    { x: p2.x + ex - center.x, y: p2.y + ey - center.y },
                    { x: p1.x + ex - center.x, y: p1.y + ey - center.y }
                ];
                bodies.push(scene.matter.add.fromVertices(center.x, center.y, vertices, { 
                    isStatic: true,
                    restitution: 0.7, 
                    friction: 0.05
                }));
            }
            return bodies;
        }

        // --- STATE ---
        const LAPS_TO_WIN = 3;

        // Robust Volume Initialization to avoid NaN/non-finite errors
        let savedVol = localStorage.getItem('neon-volume');
        let initialVolume = 0.1;
        if (savedVol !== null) {
            let parsed = parseFloat(savedVol);
            if (!isNaN(parsed) && isFinite(parsed)) {
                initialVolume = parsed;
            }
        }

        const Net = {
            peer: null,
            myId: null,
            creatorId: null,
            playerName: localStorage.getItem('p2p-racer-name') || "Racer_" + Math.floor(Math.random()*999),
            carType: localStorage.getItem('p2p-racer-car') || 'car1',
            volume: initialVolume,
            connections: {},
            players: {},
            isHost: false,
            ready: false,
            gameOver: false
        };

        window.onerror = (msg, url, line) => {
            const errBox = document.getElementById('error-log');
            errBox.style.display = 'block';
            errBox.innerText = `Crash: ${msg}\nLine: ${line}`;
            return false;
        };

        window.onload = () => {
            if (typeof Phaser === 'undefined' || typeof Peer === 'undefined') {
                document.getElementById('loading-msg').innerText = "Library Load Failed";
                return;
            }
            startGame();
        };

        function startGame() {
            class NetworkManager {
                constructor(sceneEventBus) {
                    this.events = sceneEventBus;
                }

                init() {
                    if (Net.peer) return;
                    Net.peer = new Peer(null, { debug: 1 });
                    Net.peer.on('open', (id) => {
                        Net.myId = id;
                        Net.players[id] = { id, name: Net.playerName, carType: Net.carType, x: 0, y: 0, angle: 0, laps: 0 };
                        this.events.emit('net-ready', id);
                    });
                    Net.peer.on('connection', (conn) => this.handleConnection(conn));
                }

                connectToPeer(hostId) {
                    if(!Net.peer || hostId === Net.myId) return;
                    Net.creatorId = hostId;
                    const conn = Net.peer.connect(hostId);
                    this.handleConnection(conn);
                }

                handleConnection(conn) {
                    conn.on('open', () => {
                        Net.connections[conn.peer] = conn;
                        conn.send({ 
                            type: 'HELLO', 
                            player: Net.players[Net.myId], 
                            creatorId: Net.creatorId 
                        });
                        if (Object.keys(Net.players).length > 1) {
                            conn.send({ type: 'PEER_LIST', list: Object.keys(Net.players), creatorId: Net.creatorId });
                        }
                        this.updateHostStatus();
                        this.events.emit('player-updated');
                    });
                    conn.on('data', (data) => this.handleData(conn.peer, data));
                    conn.on('close', () => this.removePlayer(conn.peer));
                    conn.on('error', () => this.removePlayer(conn.peer));
                }

                handleData(senderId, data) {
                    switch(data.type) {
                        case 'HELLO':
                            if (data.creatorId && !Net.creatorId) Net.creatorId = data.creatorId;
                            if (!Net.players[senderId]) {
                                Net.players[senderId] = { ...data.player };
                                this.updateHostStatus();
                                this.events.emit('player-updated');
                            }
                            break;
                        case 'PEER_LIST':
                            if (data.creatorId && !Net.creatorId) Net.creatorId = data.creatorId;
                            data.list.forEach(id => (id !== Net.myId && !Net.connections[id]) && this.connectToPeer(id));
                            break;
                        case 'START_GAME':
                            this.events.emit('start-game');
                            break;
                        case 'GAME_UPDATE':
                            if (Net.players[senderId]) {
                                Object.assign(Net.players[senderId], data);
                            }
                            break;
                        case 'RACE_FINISHED':
                            this.events.emit('race-finished', data.winnerId);
                            break;
                        case 'RESET_TO_LOBBY':
                            this.events.emit('reset-to-lobby');
                            break;
                    }
                }

                broadcast(data) {
                    Object.values(Net.connections).forEach(c => c.open && c.send(data));
                }

                removePlayer(id) {
                    delete Net.players[id];
                    delete Net.connections[id];
                    this.updateHostStatus();
                    this.events.emit('player-left', id);
                    this.events.emit('player-updated');
                }

                updateHostStatus() {
                    const allIds = Object.keys(Net.players).sort();
                    if (Net.creatorId && Net.players[Net.creatorId]) {
                        Net.isHost = (Net.myId === Net.creatorId);
                    } else {
                        const newHostId = allIds[0];
                        if (Net.creatorId !== newHostId) {
                            Net.creatorId = newHostId;
                            if (Net.myId === Net.creatorId) this.events.emit('becoming-host');
                        }
                        Net.isHost = (Net.myId === Net.creatorId);
                    }
                }
            }

            const eventBus = new Phaser.Events.EventEmitter();
            const network = new NetworkManager(eventBus);

            // --- MENU SCENE ---
            class MenuScene extends Phaser.Scene {
                constructor() { super('Menu'); }
                preload() {
                    this.load.image('car1', 'https://colinjk.github.io/ct-arcade-01-26/car1-sprite.png');
                    this.load.image('car2', 'https://colinjk.github.io/ct-arcade-01-26/car2-sprite.png');
                    this.load.image('car3', 'https://colinjk.github.io/ct-arcade-01-26/car3-sprite.png');
                    this.load.image('track_img', 'https://colinjk.github.io/ct-arcade-01-26/track.png');
                    this.load.audio('bgm', 'https://colinjk.github.io/ct-arcade-01-26/bg-music.wav');
                    this.load.audio('accel', 'https://colinjk.github.io/ct-arcade-01-26/accel.wav');
                }

                create() {
                    document.getElementById('loading-msg').style.display = 'none';
                    document.getElementById('hud').classList.add('hidden');
                    document.body.style.backgroundImage = "url('https://colinjk.github.io/ct-arcade-01-26/menu-background.png')";
                    
                    network.init();
                    Net.ready = true;
                    Net.gameOver = false;
                    
                    // Final sanity check for volume value
                    const safeVolume = (isNaN(Net.volume) || !isFinite(Net.volume)) ? 0.1 : Net.volume;
                    this.sound.volume = safeVolume;

                    const ui = document.getElementById('ui-layer');
                    const content = document.getElementById('ui-content');
                    const titleImg = document.getElementById('ui-title-img');
                    const titleText = document.getElementById('ui-title-text');
                    
                    ui.classList.remove('hidden');
                    titleImg.classList.remove('hidden');
                    titleText.classList.add('hidden');
                    
                    this.renderMenu(content);
                    eventBus.on('net-ready', (id) => {
                        const msg = document.getElementById('status-msg');
                        if(msg) msg.innerText = "Network Ready: " + id;
                    });
                }

                renderMenu(container) {
                    container.innerHTML = `
                        <label>YOUR NAME</label>
                        <input type="text" id="inp-name" value="${Net.playerName}" maxlength="12">
                        
                        <label>CHOOSE YOUR CAR</label>
                        <div class="car-selector">
                            <div class="car-option ${Net.carType === 'car1' ? 'selected' : ''}" data-car="car1">
                                <img src="https://colinjk.github.io/ct-arcade-01-26/car1-sprite.png">
                            </div>
                            <div class="car-option ${Net.carType === 'car2' ? 'selected' : ''}" data-car="car2">
                                <img src="https://colinjk.github.io/ct-arcade-01-26/car2-sprite.png">
                            </div>
                            <div class="car-option ${Net.carType === 'car3' ? 'selected' : ''}" data-car="car3">
                                <img src="https://colinjk.github.io/ct-arcade-01-26/car3-sprite.png">
                            </div>
                        </div>

                        <button id="btn-create" style="width:100%; margin-top:10px;">Create Game</button>
                        <input type="text" id="inp-room" placeholder="Paste ID here" style="margin-top:10px;">
                        <button id="btn-join" style="width:100%;">Join Game</button>
                        
                        <div id="settings-panel">
                            <label>VOLUME (${Math.round(Net.volume * 100)}%)</label>
                            <input type="range" id="vol-slider" min="0" max="1" step="0.05" value="${Net.volume}">
                        </div>

                        <div id="status-msg" style="margin-top:15px; font-size:11px; color:#00bcd4;">Connecting...</div>
                    `;

                    // Listeners
                    const volSlider = document.getElementById('vol-slider');
                    volSlider.oninput = (e) => {
                        let newVol = parseFloat(e.target.value);
                        if (isNaN(newVol) || !isFinite(newVol)) newVol = 0.1;
                        Net.volume = newVol;
                        this.sound.volume = Net.volume;
                        localStorage.setItem('neon-volume', Net.volume);
                        volSlider.previousElementSibling.innerText = `VOLUME (${Math.round(Net.volume * 100)}%)`;
                    };

                    container.querySelectorAll('.car-option').forEach(opt => {
                        opt.onclick = () => {
                            container.querySelectorAll('.car-option').forEach(o => o.classList.remove('selected'));
                            opt.classList.add('selected');
                            Net.carType = opt.dataset.car;
                        };
                    });

                    document.getElementById('btn-create').onclick = () => {
                        this.saveSettings();
                        Net.creatorId = Net.myId;
                        this.scene.start('Lobby');
                    };
                    document.getElementById('btn-join').onclick = () => {
                        const room = document.getElementById('inp-room').value.trim();
                        if (room) { 
                            this.saveSettings();
                            network.connectToPeer(room); 
                            this.scene.start('Lobby'); 
                        }
                    };
                }

                saveSettings() {
                    const name = document.getElementById('inp-name').value.trim() || "Racer";
                    Net.playerName = name;
                    localStorage.setItem('p2p-racer-name', name);
                    localStorage.setItem('p2p-racer-car', Net.carType);
                    if (Net.players[Net.myId]) {
                        Net.players[Net.myId].name = name;
                        Net.players[Net.myId].carType = Net.carType;
                    }
                }
            }

            // --- LOBBY SCENE ---
            class LobbyScene extends Phaser.Scene {
                constructor() { super('Lobby'); }
                create() {
                    const ui = document.getElementById('ui-layer');
                    const content = document.getElementById('ui-content');
                    const titleImg = document.getElementById('ui-title-img');
                    const titleText = document.getElementById('ui-title-text');

                    ui.classList.remove('hidden');
                    titleImg.classList.add('hidden');
                    titleText.classList.remove('hidden');
                    titleText.innerText = "LOBBY";
                    
                    this.render(content);
                    eventBus.on('player-updated', () => this.render(content));
                    eventBus.on('start-game', () => this.startGame());
                }

                render(container) {
                    const hostId = Net.creatorId;
                    let html = `<div style="margin-bottom:15px; background:#111; padding:12px; border-radius:4px; border:1px solid #333;">
                        <span style="color:#888; font-size:11px; letter-spacing:1px;">ROOM ID</span><br>
                        <b style="color:#00bcd4; font-size:18px;">${hostId || 'Generating...'}</b>
                        <button onclick="window.copyToClipboard('${hostId}')" style="padding:4px 8px; font-size:10px; margin-left:10px; background:#333; color:white;">COPY</button>
                    </div><div style="text-align:left; background:#000; padding:10px; border-radius:4px;">`;

                    Object.values(Net.players).forEach(p => {
                        html += `<div style="padding:8px; border-bottom:1px solid #222; display:flex; justify-content:space-between; align-items:center;">
                            <span style="color:#fff">‚óè ${p.name || 'Unknown'}</span>
                            <div style="display:flex; align-items:center; gap:10px;">
                                <img src="https://colinjk.github.io/ct-arcade-01-26/${p.carType}-sprite.png" style="height:20px;">
                                <span style="font-size:10px; color:#555;">${p.id === hostId ? 'HOST' : 'PEER'}</span>
                            </div>
                        </div>`;
                    });

                    html += `</div>`;
                    if (Net.isHost) {
                        html += `<button id="btn-start" style="margin-top:20px; width:100%; background:#4CAF50; color:white;">START RACE</button>`;
                    } else {
                        html += `<div style="margin-top:20px; color:#666; font-style:italic;">Waiting for host to start race...</div>`;
                    }
                    container.innerHTML = html;
                    const b = document.getElementById('btn-start');
                    if (b) b.onclick = () => { network.broadcast({ type: 'START_GAME' }); this.startGame(); };
                }

                startGame() {
                    document.getElementById('ui-layer').classList.add('hidden');
                    this.scene.start('Game');
                }
            }

            // --- GAME SCENE ---
            class GameScene extends Phaser.Scene {
                constructor() { super('Game'); }
                create() {
                    Net.gameOver = false;
                    this.myLaps = 0;
                    this.hasReachedCheckpoint = false; 

                    // Audio Setup
                    if (!this.sound.get('bgm')) {
                        this.sound.play('bgm', { loop: true, volume: 0.4 });
                    }
                    this.accelSfx = this.sound.add('accel', { loop: true, volume: 0.6 });

                    document.body.style.backgroundImage = "none";
                    document.getElementById('hud').classList.remove('hidden');
                    document.getElementById('lap-counter').innerText = `LAP: 1/${LAPS_TO_WIN}`;
                    document.getElementById('btn-quit').onclick = () => window.location.reload();

                    // Track
                    this.add.image(0, 0, 'track_img').setOrigin(0);

                    // Physics Walls
                    this.matter.add.fromVertices(524, 496, [
                        {x:323, y:263},{x:721, y:264},{x:765, y:282},{x:780, y:317},{x:774, y:351},
                        {x:522, y:519},{x:501, y:562},{x:504, y:604},{x:550, y:644},{x:746, y:647},
                        {x:803, y:671},{x:809, y:714},{x:787, y:741},{x:751, y:749},{x:293, y:750},
                        {x:251, y:729},{x:244, y:682},{x:305, y:611},{x:522, y:453},{x:536, y:401},
                        {x:528, y:378},{x:479, y:344},{x:304, y:348},{x:262, y:320},{x:270, y:291},{x:302, y:271}
                    ], { isStatic: true, restitution: 0.7, friction: 0.05 });

                    createOuterWall(this, [
                        {x:313, y:208},{x:761, y:210},{x:818, y:234},{x:839, y:264},{x:854, y:346},
                        {x:832, y:398},{x:574, y:567},{x:584, y:581},{x:797, y:584},{x:862, y:622},
                        {x:885, y:670},{x:885, y:752},{x:850, y:804},{x:764, y:820},{x:264, y:823},
                        {x:180, y:780},{x:169, y:726},{x:168, y:661},{x:196, y:607},{x:463, y:423},
                        {x:463, y:414},{x:268, y:405},{x:207, y:378},{x:194, y:324},{x:196, y:278},
                        {x:231, y:223},{x:293, y:208}
                    ], 20, true);

                    this.checkpointLine = this.add.rectangle(520, 230, 10, 60, 0x00bcd4, 0.3);

                    // Grid Spawning
                    const allIds = Object.keys(Net.players).sort();
                    allIds.forEach((id, index) => {
                        const p = Net.players[id];
                        p.x = 350 + (index * 60); 
                        p.y = 785; 
                        p.angle = 0; 
                    });

                    this.playerData = {}; // { body, visual, text }
                    Object.values(Net.players).forEach(p => this.spawn(p));

                    this.keys = this.input.keyboard.addKeys({ 
                        up: 'UP', down: 'DOWN', left: 'LEFT', right: 'RIGHT', 
                        w: 'W', a: 'A', s: 'S', d: 'D' 
                    });

                    eventBus.on('player-left', (id) => {
                        if (this.playerData[id]) {
                            this.matter.world.remove(this.playerData[id].body);
                            this.playerData[id].visual.destroy();
                            this.playerData[id].text.destroy();
                            delete this.playerData[id];
                        }
                    });

                    eventBus.on('race-finished', (winnerId) => this.showResult(winnerId));
                    eventBus.on('reset-to-lobby', () => this.scene.start('Lobby'));
                }

                spawn(p) {
                    // Hidden Physics Body
                    const body = this.matter.add.rectangle(p.x, p.y, 25, 12, {
                        frictionAir: 0.08,
                        mass: 1,
                        restitution: 0.6,
                        label: p.id
                    });
                    this.matter.body.setAngle(body, 0); // 0 rad is Right

                    // Visual Component - This is NOT a matter object, prevented spin loop
                    const visual = this.add.image(p.x, p.y, p.carType).setScale(0.4);
                    
                    const text = this.add.text(0, 0, p.name || p.id.substr(0,4), { 
                        fontSize: '11px', fontStyle: 'bold', fill: '#fff',
                        backgroundColor: '#000000cc', padding: { x: 4, y: 2 }
                    }).setOrigin(0.5).setDepth(100);

                    this.playerData[p.id] = { body, visual, text };
                }

                update() {
                    if (Net.gameOver) return;
                    const my = this.playerData[Net.myId];
                    if (my) {
                        const b = my.body;
                        const thrustForce = 0.0035;
                        const rotationSpeed = 0.09;

                        let isThrottling = false;

                        if (this.keys.up.isDown || this.keys.w.isDown) {
                            isThrottling = true;
                            const angle = b.angle;
                            this.matter.applyForce(b, {
                                x: Math.cos(angle) * thrustForce,
                                y: Math.sin(angle) * thrustForce
                            });
                        } else if (this.keys.down.isDown || this.keys.s.isDown) {
                            isThrottling = true;
                            const angle = b.angle;
                            this.matter.applyForce(b, {
                                x: -Math.cos(angle) * (thrustForce / 2),
                                y: -Math.sin(angle) * (thrustForce / 2)
                            });
                        }
                        
                        if (this.keys.left.isDown || this.keys.a.isDown) {
                            this.matter.body.setAngle(b, b.angle - rotationSpeed);
                        } else if (this.keys.right.isDown || this.keys.d.isDown) {
                            this.matter.body.setAngle(b, b.angle + rotationSpeed);
                        }

                        // SFX Logic
                        if (isThrottling && !this.accelSfx.isPlaying) {
                            this.accelSfx.play();
                        } else if (!isThrottling && this.accelSfx.isPlaying) {
                            this.accelSfx.stop();
                        }

                        // Checkpoint Logic
                        if (!this.hasReachedCheckpoint && b.position.x > 500 && b.position.y < 300) {
                            this.hasReachedCheckpoint = true;
                            this.checkpointLine.setFillStyle(0x00ff00, 0.5);
                        }

                        // Lap Logic
                        if (this.hasReachedCheckpoint && b.position.x < 300 && b.position.y > 700) {
                            this.myLaps++;
                            this.hasReachedCheckpoint = false;
                            this.checkpointLine.setFillStyle(0x00bcd4, 0.3);
                            document.getElementById('lap-counter').innerText = `LAP: ${Math.min(this.myLaps + 1, LAPS_TO_WIN)}/${LAPS_TO_WIN}`;
                            
                            if (this.myLaps >= LAPS_TO_WIN) {
                                Net.gameOver = true;
                                if(this.accelSfx) this.accelSfx.stop();
                                network.broadcast({ type: 'RACE_FINISHED', winnerId: Net.myId });
                                this.showResult(Net.myId);
                            }
                        }

                        // Broadcast raw physics state
                        network.broadcast({ 
                            type: 'GAME_UPDATE', x: b.position.x, y: b.position.y, angle: b.angle, 
                            laps: this.myLaps, name: Net.playerName, carType: Net.carType
                        });
                    }

                    // Visual Rendering Sync
                    Object.keys(Net.players).forEach(id => {
                        const obj = this.playerData[id];
                        if (obj) {
                            const data = Net.players[id];
                            if (id !== Net.myId) {
                                obj.visual.x = Phaser.Math.Linear(obj.visual.x, data.x, 0.2);
                                obj.visual.y = Phaser.Math.Linear(obj.visual.y, data.y, 0.2);
                                // Set visual orientation from synced physics angle + 90deg offset
                                obj.visual.setAngle(Phaser.Math.RadToDeg(data.angle) + 90);
                            } else {
                                // Local Sync
                                obj.visual.x = obj.body.position.x;
                                obj.visual.y = obj.body.position.y;
                                obj.visual.setAngle(Phaser.Math.RadToDeg(obj.body.angle) + 90);
                            }
                            obj.text.setPosition(obj.visual.x, obj.visual.y - 30);
                            obj.text.setText(data.name || id.substr(0,4));
                        }
                    });
                }

                showResult(winnerId) {
                    Net.gameOver = true;
                    if(this.accelSfx) this.accelSfx.stop();
                    const ui = document.getElementById('ui-layer');
                    const content = document.getElementById('ui-content');
                    const titleText = document.getElementById('ui-title-text');
                    const titleImg = document.getElementById('ui-title-img');
                    
                    const isWinner = winnerId === Net.myId;
                    ui.classList.remove('hidden');
                    titleImg.classList.add('hidden');
                    titleText.classList.remove('hidden');
                    titleText.innerText = isWinner ? "üèÜ VICTORY!" : "üèÅ RACE OVER";
                    titleText.style.color = isWinner ? "#FFD700" : "#00bcd4";

                    content.innerHTML = `
                        <div style="font-size:20px; margin:15px 0; color:#fff">
                            ${Net.players[winnerId]?.name || 'Unknown'} wins!
                        </div>
                        <div id="result-buttons">
                            ${Net.isHost ? '<button id="btn-lobby" style="width:100%;">Return to Lobby</button>' : '<p style="color:#666; font-size:12px;">Waiting for host to reset race...</p>'}
                            <button id="btn-menu" class="btn-secondary" style="width:100%;">Exit to Menu</button>
                        </div>
                    `;
                    document.getElementById('hud').classList.add('hidden');

                    if (Net.isHost) {
                        document.getElementById('btn-lobby').onclick = () => {
                            network.broadcast({ type: 'RESET_TO_LOBBY' });
                            this.scene.start('Lobby');
                        };
                    }
                    document.getElementById('btn-menu').onclick = () => window.location.reload();
                }
            }

            const config = {
                type: Phaser.AUTO,
                width: 950,
                height: 850,
                backgroundColor: '#0a0a0a',
                parent: 'game-container',
                physics: { 
                    default: 'matter', 
                    matter: { 
                        gravity: { x: 0, y: 0 },
                        debug: false 
                    } 
                },
                scene: [MenuScene, LobbyScene, GameScene]
            };
            new Phaser.Game(config);
        }
    </script>
</body>
</html>
